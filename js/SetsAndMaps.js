'use strict';

// Data needed for a later exercise
const flights =
  '_Delayed_Departure;fao93766109;txl2133758440;11:25+_Arrival;bru0943384722;fao93766109;11:45+_Delayed_Arrival;hel7439299980;fao93766109;12:05+_Departure;fao93766109;lis2323639855;12:30';


// Data needed for first part of the section
// Перенесем для показа вн объекта ресторан

// Треьим расширением ясвляется то, что мы можем вычислить(компилировать) имена свойств вместо написания их вручную и буквально. То есть вычислитяь

const weekdays = ['mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun'];
const openingHours = {
  // То есть вместо thu . Мы можем написать [weekdays[3]]. Также здесь можно использовать деструктуризацию . Также в значениях можно указать например 12-12
  [weekdays[3]]: {
    open: 12,
    close: 22,
  },
  [weekdays[4]]: {
    open: 11,
    close: 23,
  },
  [weekdays[5]]: {
    open: 12 - 12, // Open 24 hours
    close: 24,
  },
};


const restaurant = {
  name: 'Classico Italiano',
  location: 'Via Angelo Tavanti 23, Firenze, Italy',
  categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],
  starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],
  mainMenu: ['Pizza', 'Pasta', 'Risotto'],

  // Второе расширение объектных литеролов при написании методов 
  // Теперь мы можем не писать : function. И Js поймет что это метод и подсветит так же зеленым цветом
  order(starterIndex, mainIndex) {
    return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];
  },

  // До ES6 мы должны были писать так, если мы обращались к объекту извне. И тогда у нас снова появлялось данное свойство
  // openingHours:openingHours,

  // Но раздражение было в том что, имя свойства и имя переменной(объекта) совпадали, которое мы получили из нового объекта(openingHours)
  // Но после ES6 мы можем написать просто объект
  // ES6 enchanced object literals 
  openingHours,


  orderDelivery({
    starterIndex = 1,
    mainIndex = 0,
    time = '20:00',
    address
  }) {
    console.log(`Order received ${this.mainMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`);
  },

  // У пасты будут 3 обязательных ингридиента
  orderPasta(ing1, ing2, ing3) {
    console.log(`Here is your declicious pasta with ${ing1}, ${ing2}, ${ing3}`);
  },

  //Напишем метод заказа пиццы с помощью оператора rest 
  //Для нашей пиццы должен быть 1 обязательный ингридиент, а остальные опциональные 
  orderPizza(mainIngrideinet, ...otherIngridients) {
    console.log(mainIngrideinet);
    console.log(otherIngridients);
  },


  // Попробовать саммому 
  orderPizzaStr(mainIngrideinet, ...otherIngridients) {
    console.log(`Main ingridient ${mainIngrideinet}; Others ingtiditnrs ${otherIngridients}`);
  },

};




// Sets - Одна из data structure добавленных в ES6

// Объекты Set позволяют вам сохранять уникальные значения любого типа, как примитивы, так и другие типы объектов.
// Это ознначает, что  set не может иметь дубликаты. И это свойство делает его полезным в определленных ситуациях

// Создадим новый set с помощью new Set и в круглые скобки() помещаем iterable . Самым распространенным iterable является массив
const ordersSet = new Set(['Pasta', 'Pizza', 'Pizza', 'Risotto', 'Pasta', 'Pizza']); // Поместим массив, с несколькими значениями 

// Мы поместили в массив 6 строк, но также может быть любой тип данных(число или булеан например). Set может работьть с любым типом данных, в этом нет никакой проблемы
console.log(ordersSet); // Выведит Set(3) с размером 3(указан в скобках) и значения содержащиеся внутри  {'Pasta', 'Pizza', 'Risotto'}

// У Set мы видим сходство с массивом. Так как у них нет пар ключ,значение. А имеется просто набор значений сгрупированных вместе в данном случае в Set 

// Так же как массивы Set является iterables
// Но Set остается разным в отличие от массива. Во первых потому, что его элементы уникальны. Во вторых, потому что порядок элементов set не имеет значения.

// Надо помнить, что сткроки тоже являются iterables и мы можем делать следующее. Мы можем передать строку 
console.log(new Set(`Jonas`)); // Set(5) {'J', 'o', 'n', 'a', 's'}. Здесь получим Set с 5 элементами. Которые являются компонентами данной, строки которая является iterables   

// Так же Set может быть пустым
console.log(new Set());// Set(0) {size: 0}


// Раююота с Set
// Мы можем получить размер Set(сета) с помощью свойства size (ordersSet.size)
console.log(ordersSet.size);

//Это может быть полезно например, для шефа ресторана, узнать сколько блюд здесь готовится. То есть узначем, что готовится 3 разных блюда

// Тажкде у сет есть метод has() - который проверяет наличие элемента у сета. этот метод похож на метод includes у массивов
console.log(ordersSet.has('Pizza')); // true
console.log(ordersSet.has('Garlic Bread')); // false

// Также мы можем добавлять новые элементы в set.add() (у массивов push)
ordersSet.add('Garlic Bread');
ordersSet.add('Garlic Bread'); // Даже жобавить одинаковые элементы. Сет записвает только уникальные значения элементов. Добавление одинакового элемента будет проигнорировано 

// Также м можем удалить элемент set.delete(). У массива нет такого простого метода дл удаления, как у сета
ordersSet.delete('Risotto');
console.log(ordersSet);

// У Set нету индексов и пооэтому нет способа получить значения из set
// Если задуматься нам не надо получить данные из сет, потому что если все значения уникальны, то не важен их порядок. Поэтому нет смысла извлекать данные из set. Все что нам надо знать, является ли определленное значение в set(наборе) или нет. Поэтому есть метод has

// Если наша цель хранить значение в определенном порядке и извлекать их. То тогда лучшим рещением будет использовать массивы array. Set(набор) для этого не используется, потому что для этого мы используем массив

// Метод удаляющий все элементы из набора(set)
//ordersSet.clear();
//console.log(ordersSet);  // Выведится пустой набор Set(0) {size: 0}

// Set (набор) также являеся iterables(перечисляемым). И поэтому мы можим проходить циклом по нему

for(const order of ordersSet) console.log(order); // По отдельности вывелутся элементы на каждой итерации цикла

// Циклирование возможно как и любое перечисление(iterables) 

// Обычной практикой применения набора(set) является удаление дубликатов из массива

// Example
const staff = ['Waiter', 'Chef', 'Waiter', 'Manager', 'Chef', 'Waiter'];
// Создадим set(набор) new Set(staff) и в скобках нужно вставить iterables(перечесляемое) в нашем случае это массив
const staffUnique = [...new Set(staff)]; // Для конверстации из Set(набора) обратно в массив мы можем воспользоваться оператором spread (... справа). Потому что spread operator работает со всеми iterales(перечесляемыми). То есть все элементы будут положены в новыйс обранный массив

console.log(staffUnique); // ['Waiter', 'Chef', 'Manager']
 
// Если нам не нужен будет сам массив. А нужно количество уникальных значений, то тогда мы можем воспользоваться методом size так
console.log(
  new Set(['Waiter', 'Chef', 'Waiter', 'Manager', 'Chef', 'Waiter']).size
  ); // Введится 3, так как 3 уникахльных значения
 
// Также будет работать если нам нужно узнать количество уникальных букв в строке
console.log(new Set('jonasschedtmann').size); // 11 уникальных букв

// Подитожим. Set(набор) не предназначен заменить массив. Когда нужно хранить данные в порядке(определенном),  и возможны дубликаты, то тогда всегда используем массивы, также когда нужно манипулировать с данными. Потому что у массива есть много хороших методов

// Set's(наборы) не так важны, как массивы, но если надо работать с уникальными значениями, то тогда  лучше использовать Set's (Наборы)




// Maps: Fundametals

// Map Намного полезнее чем set's(наборы) она является тоже data structure
// Map – это коллекция ключ/значение, как и Object . Но основное отличие в том, что Map позволяет использовать ключи любого типа. Методы и свойства: new Map() – создаёт коллекцию.

// Но большая разница между объектами(objects) и maps . Заключается в том что ключи могут иметь любой тип данных. А у Objects ключи (свойства) всегда являются строками(strings)

// То есть ключом в Map могут быть даже объекты, массивы или другие Map

// Самый простой способ создания Map является создание пустого Map
const rest = new Map();

// А затем заполнить(fill up) его используя метод set. Этот метод поход на метод add у Set
rest.set('name', 'Classico Italiano'); // Вначале передаем имя ключа, а затем его value 

// Надо не забывать, что мы можем использовать любой типд данных. 
// Например у ресторана 2 адреса. Мы создадим ключ с номером(цифрой)
rest.set(1,'Fireze, Italy');
// Метод Set не только вызывает функцию ну и возвращает Map как показано ниже через консоль лог(то есть то выражение выдаст полный Map, поэтому мы и смогли вывести через cl)

console.log(rest.set(2,'Lisbon, Portigal')); // Покажет одно и тоже Map(3) {'name' => 'Classico Italiano', 1 => 'Fireze, Italy', 2 => 'Lisbon, Portigal'}
console.log(rest); // Покажет одно и тоже Map(3) {'name' => 'Classico Italiano', 1 => 'Fireze, Italy', 2 => 'Lisbon, Portigal'}

// То есть метод Set вовзращает обновленый Map
// Поэтому это нам позволяет изменить метод set  следующим образом (как показано ниже -то ет ьсподряд идет несколько изменений )
// Еще раз значение и ключ могут быть хоть ччем(массивом, строкой, объектом, map и т.д.)

rest
.set('categories', ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'])
.set('open',11)
.set('close', 23) // Мы можем и дальше делать добавим булевые значения
.set(true, 'We are open :D')
.set(false, 'We are closed :(');
console.log(rest);


//Чтобы прочесть данные из Map мы используем метод Get(который доступен ко всем Map's). Для этого нам нужно передат ьимя ключа
console.log(rest.get('name')); // Classico Italiano
console.log(rest.get(true)); // We are open :D 
console.log(rest.get(1));

// К ообращению ключа важно соблюдать тип данных иначе в результате у нас получится undefined 


// Используем булевые ключи
// Допустим у нас есть текущее время

const time = 20; // Пока захордкодим, так какпока не значем как его получить с помощью js
console.log(rest.get(time >= rest.get('open') && time < rest.get('close'))) ; // То есть мы прописали для метода get условия, если верно то выведится true а если нет то false 

// Выше написанная строчка хорошая, но не очень читаемая, поэтому с такой записью лучше не злоупотрелять . Это показ, что булевые значения могут иметь быть ключами у Map 


// Метод проверяющий наличие ключа у Map - has
console.log(rest.has('categories')); // true

// Удаление пары ключ- значение с помощью метода delete
rest.delete(2);
console.log(rest); // Теперь локации второго ресторана пропала из Map

// В сравнении с объектами. В объектах тоже есть возможность удаления свойств используя Delete Operator. Но это очень медлынный  процесс и обычно это не рекомендуется делать. 
// Так же у объектов есть схожий метод на метод -has у Map и он называется hasOwnProperty  

// Также у Map есть свойсво size(не метод так как не являетс функцией), который покажет количество свойтв у Map
//console.log(rest.size); // 7

// И также есть методл clear - который удалет все элементы из Map
//rest.clear();


const arr = [1,2];
// Исполдьзование объектов и массивов в качестве ключей у map
rest.set(arr, 'Test');//key: (2) [1, 2] value: "Test"
console.log(rest.size); // 7
console.log(rest.get(arr)); // Чтобы был одним же объектом используем arr
//console.log(rest.get([1,2])); // Мы получим undefined. Так как мы узнали из прошлой секции по тому как js работает за сценойю. В частности, примитивы против объектов(то есть их разница в стеке и куче)

// Причиной результата undefined является то, что  Эти два массива на 237 строчке и 240 строчке, являются не одним и тем же объектом. Даже не смотря на то что они записаны тем же способом. Они не один и тот же объект 
//  На 237 строке ключ ([1,2]) является именно этим объектом, в памяти, не тем который прописан на 240 строке  . И поэтому это не может работать 

// Чтобы это зарабоатало нам нужно создать массив  (на 235 строке )
// И затем использовать arr, вместо [1,2]. Это будет работать потому что они будут ссылаться на одно и тоже место в памяти 
console.log(rest.get(arr)); // Теперь выведится значение Test, ключом которого является массив

// Выше с помощтю массивов мы доказали, что можем действительно использовать объекты в качестве Map keys . Это может быть очень полезным с dumb elements(немыми элементами), которые по факту также ничего больше чем просто специальный тип объекта
// Напишем ниже- в качестве ключа используем document.querySelector('h1'). И его результатом(values) будет объект
rest.set(document.querySelector('h1'), 'Heading')
// При наведении на ключ h1 будет выделяться h1 элемент на вэб странице. Это определнно будет ключом этого Map entry(записью или входом)




// MAPS: Ireation - Итерация Map's(мапов  )
